<?xml version="1.0" encoding="utf-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.5.xsd">

    <changeSet id="20250814001" author="Manuel">
        <createProcedure dbms="postgresql">
        <![CDATA[
            CREATE OR REPLACE FUNCTION public.register_integration_suricata(srv_id integer)RETURNS void
            LANGUAGE plpgsql
            AS
                $function$
                declare
                    grp_id integer;
                    mod_id bigint;

                        begin
                            INSERT INTO utm_module (pretty_name, module_description, module_active, module_icon, module_name,
                                                    server_id, module_category, needs_restart, lite_version, is_activatable)
                            VALUES ('Suricata',
                                    'Suricata is an open-source based intrusion detection system (IDS) and intrusion prevention system (IPS).',
                                    FALSE,
                                    'suricata.png',
                                    'SURICATA',
                                    srv_id,
                                    'Device',
                                    FALSE,
                                    TRUE,
                                    TRUE)
                                ON CONFLICT (module_name, server_id) DO UPDATE SET pretty_name        = 'Suricata',
                                                                            module_icon        = 'suricata.png',
                                                                            module_name        = 'SURICATA',
                                                                            module_category    = 'Device',
                                                                            module_description = 'Suricata is an open-source based intrusion detection system (IDS) and intrusion prevention system (IPS).',
                                                                            lite_version       = TRUE,
                                                                            server_id          = srv_id;

                            end;
                $function$;
            ]]>
        </createProcedure>

        <createProcedure dbms="postgresql">
            <![CDATA[
                create or replace function register_integrations(srv_id integer, srv_type character varying)
                    returns void
                    language plpgsql
                    as
                $$
                BEGIN

                    perform public.register_integration_netflow(srv_id);

                    perform public.register_integration_window_agent(srv_id);

                    perform public.register_integration_syslog(srv_id);

                    perform public.register_integration_vmware(srv_id);

                    perform public.register_integration_linux_agent(srv_id);

                    perform public.register_integration_apache(srv_id);

                    perform public.register_integration_linux_audit_demon(srv_id);

                    perform public.register_integration_elasticsearch(srv_id);

                    perform public.register_integration_hap(srv_id);

                    perform public.register_integration_kafka(srv_id);

                    perform public.register_integration_kibana(srv_id);

                    perform public.register_integration_logstash(srv_id);

                    perform public.register_integration_mongodb(srv_id);

                    perform public.register_integration_mysql(srv_id);

                    perform public.register_integration_nats(srv_id);

                    perform public.register_integration_nginx(srv_id);

                    perform public.register_integration_osquery(srv_id);

                    perform public.register_integration_postgresql(srv_id);

                    perform public.register_integration_redis(srv_id);

                    perform public.register_integration_traefik(srv_id);

                    perform public.register_integration_cisco(srv_id);

                    perform public.register_integration_cisco_meraki(srv_id);

                    perform public.register_integration_json(srv_id);

                    perform public.register_integration_iis(srv_id);

                    perform public.register_integration_kaspersky(srv_id);

                    perform public.register_integration_eset(srv_id);

                    perform public.register_integration_sentinel_one(srv_id);

                    perform public.register_integration_fortigate(srv_id);

                    perform public.register_integration_sophosxg(srv_id);

                    perform public.register_integration_macos(srv_id);


                IF srv_type = 'aio' THEN

                    perform public.register_integration_file_integrity(srv_id);

                    perform public.register_integration_azure(srv_id);

                    perform public.register_integration_o365(srv_id);

                    perform public.register_integration_aws(srv_id);

                    perform public.register_integration_sophos_central(srv_id);

                    perform public.register_integration_gcp(srv_id);

                    perform public.register_integration_fire_power(srv_id);

                    perform public.register_integration_mikrotik(srv_id);

                    perform public.register_integration_palo_alto(srv_id);

                    perform public.register_integration_cisco_switch(srv_id);

                    perform public.register_integration_sonic_wall(srv_id);

                    perform public.register_integration_deceptive_bytes(srv_id);

                    perform public.register_integration_github(srv_id);

                    perform public.register_integration_bitdefender(srv_id);

                    perform public.register_integration_soc_ai(srv_id);

                    perform public.register_integration_suricata(srv_id);

                END IF;

                perform public.update_module_dependencies();
            END;
            $$;
            ]]>
        </createProcedure>
        <createProcedure dbms="postgresql">
            do
            $$
            begin
                perform public.execute_register_integration_function();
            end;
            $$
            language plpgsql;
        </createProcedure>
        <sql dbms="postgresql" splitStatements="true" stripComments="true">
            <![CDATA[

            INSERT INTO utm_data_types (id, data_type, data_type_name, data_type_description, last_update, included, system_owner)
            VALUES (49, 'suricata', 'Suricata', 'Used to filter logs and apply alerting rules related to Suricata integration', '2025-08-22 21:35:38.627000', true, true);

                INSERT INTO utm_logstash_filter (id, logstash_filter, filter_name, filter_group_id, system_owner, module_name, is_active, filter_version, data_type_id)
                VALUES (1530, $$

                    # Suricata filter version 1.0.0
# Based on https://suricata.readthedocs.io/en/latest/output/eve/eve-json-format.html (latest 8.0.0) (august 2025)
# and real events log provided
# Support json format

pipeline:
  - dataTypes:
      - suricata
    steps:
      # Drop log incomplete jSon structure
      - drop:
          where: safe("raw", "").matches(".*\\\"event_type\\\"\\s*:\\s*\\\"stats\\\".*")

      # Parsing RAW field log
      - grok:
          patterns:
            - fieldName: log.syslogPri
              pattern: '\<{{.integer}}\>'
            - fieldName: log.syslogTimestamp
              pattern: '{{.monthName}}(\s+){{.monthDay}}(\s+){{.time}}'
            - fieldName: log.syslogHost
              pattern: '{{.hostname}}'
            - fieldName: log.syslogProgram
              pattern: '{{.word}}'
            - fieldName: log.syslogPid
              pattern: '\[{{.integer}}\]: '
            - fieldName: log.suricataJson
              pattern: '{{.greedy}}'

      # Parse Suricata JSON logs
      - json:
          source: log.suricataJson
          where: safe("log.suricataJson", "").matches("^\\{.*\\}$")

      # Rename fields to conversion v11 schema
      - rename:
          from:
            - log.destip
          to: target.ip

      - rename:
          from:
            - log.destport
          to: target.port

      - rename:
          from:
            - log.flowid
          to: log.flowId

      - rename:
          from:
            - log.host
          to: target.host

      - rename:
          from:
            - log.iniface
          to: log.inFace

      - rename:
          from:
            - log.srcip
          to: origin.ip

      - rename:
          from:
            - log.srcport
          to: origin.port

      - rename:
          from:
            - log.txid
          to: log.txId

      - rename:
          from:
            - log.eventtype
          to: log.eventType

      - rename:
          from:
            - log.appproto
          to: log.appProto

      - rename:
          from:
            - log.proto
          to: protocol


      # Adding severity field based on log.alert.severity
      - add:
          function: "string"
          params:
            key: severity
            value: "low"
          where: safe("log.alert.severity", 0.0) == double(1)

      - add:
          function: "string"
          params:
            key: severity
            value: "medium"
          where: safe("log.alert.severity", 0.0) == double(2)

      - add:
          function: "string"
          params:
            key: severity
            value: "high"
          where: safe("log.alert.severity", 0.0) == double(3)

      #.......................................................................
      # Add new eventtypes to logx structure, detected in real logs, present in suricata 7.0.0
      - rename:
          from:
            - log.ftpdata
          to: log.ftpData

      - rename:
          from:
            - log.fileinfo
          to: log.fileInfo

      # Implementing action field used for established connections
      - add:
          function: "string"
          params:
            key: action
            value: "success"
          where: (safe("log.eventType", "") == "tls" && exists("log.tls.sessionresumed")) ||
            (safe("log.eventType", "") == "dns" && safe("log.dns.type", "") == "answer") ||
            (safe("log.eventType", "") == "flow" && exists("origin.ip") && exists("target.ip") && safe("log.flow.bytestoserver", 0.0) > double(0) && safe("log.flow.bytestoclient", 0.0) > double(0)) ||
            (safe("log.eventType", "") == "ssh" && exists("log.ssh.server") && exists("log.ssh.client")) ||
            (safe("log.eventType", "") == "alert" && exists("origin.ip") && exists("target.ip") && safe("log.alert.action", "") == "allowed" && safe("log.flow.bytestoserver", 0.0) > double(0) && safe("log.flow.bytestoclient", 0.0) > double(0)) ||
            (safe("log.eventType", "") == "http" && exists("origin.ip") && exists("target.ip") && exists("log.http.status")) ||
            (safe("log.eventType", "") == "ftp" && exists("origin.ip") && exists("target.ip") && exists("log.ftp.completioncode")) ||
            (safe("log.eventType", "") == "tftp" && exists("origin.ip") && exists("target.ip") && safe("log.tftp.packet", "") != "error") ||
            (safe("log.eventType", "") == "smb" && exists("origin.ip") && exists("target.ip") && safe("log.smb.command", "") in ["NEGOTIATE"] && safe("log.smb.status", "") in ["SUCCESS", "GRANTED", "CONNECTED"]) ||
            (safe("log.eventType", "") == "rdp" && exists("origin.ip") && exists("target.ip") && (safe("log.rdp.eventType", "") == "connectresponse" || safe("log.rdp.eventType", "") == "tlshandshake")) ||
            (safe("log.eventType", "") == "rfb" && exists("origin.ip") && exists("target.ip") && safe("log.rfb.authentication.security-result", "") == "OK") ||
            (safe("log.eventType", "") == "mqtt" && exists("origin.ip") && exists("target.ip") && (safe("log.mqtt.connack.returncode", "") == "0" ||  safe("log.mqtt.connack.returncode", "") == "0x00")) ||
            (safe("log.eventType", "") == "pgsql" && exists("origin.ip") && exists("target.ip") && (exists("log.pgsql.request.simplequery") ||  exists("log.pgsql.response.commandcompleted") || safe("log.pgsql.response.sslaccepted", "") == "true" || safe("log.pgsql.response.accepted", "") == "true" || exists("log.pgsql.response.authenticationmd5password"))) ||
            ((safe("log.eventType", "") == "ike" || safe("log.eventType", "") == "ikev1" || safe("log.eventType", "") == "ikev2") && exists("origin.ip") && exists("target.ip")) ||
            (safe("log.eventType", "") == "modbus" && exists("origin.ip") && exists("target.ip")) ||
            (safe("log.eventType", "") == "sip" && exists("origin.ip") && exists("target.ip")) ||
            (safe("log.eventType", "") == "quic" && exists("origin.ip") && exists("target.ip")) ||
            (safe("log.eventType", "") == "fileinfo" && exists("origin.ip") && exists("target.ip")) ||
            (safe("log.eventType", "") == "snmp" && exists("origin.ip") && exists("target.ip")) ||
            (safe("log.eventType", "") == "dhcp" && exists("origin.ip") && exists("target.ip") && safe("log.dhcp.assignedip", "") != "0")


      # Adding geolocation to origin.ip
      - dynamic:
          plugin: com.utmstack.geolocation
          params:
            source: origin.ip
            destination: origin.geolocation
          where: exists("origin.ip")

      # Adding geolocation to target.ip
      - dynamic:
          plugin: com.utmstack.geolocation
          params:
            source: target.ip
            destination: target.geolocation
          where: exists("target.ip")

      # Removing unused fields
      - delete:
          fields:
            - log.suricataJson
            - log.syslogPri
            - log.syslogTimestamp
            - log.syslogProgram
            - log.syslogPid

                    $$, 'suricata', null, true, 'SURICATA', false, '2.0.0', 49);
            ]]>
        </sql>
        <sql dbms="postgresql" splitStatements="true" stripComments="true">
            <![CDATA[
                    INSERT INTO public.utm_logstash_pipeline (id, pipeline_id, pipeline_name, pipeline_status, module_name, system_owner, pipeline_description, pipeline_internal, events_out)
                    VALUES (55, 'suricata', 'Suricata', 'down', 'SURICATA', true, null, false, 0);

                    INSERT INTO utm_group_logstash_pipeline_filters (filter_id, pipeline_id, relation)
                    VALUES (1530, 55, 'PIPELINE_FILTER');

                    INSERT INTO utm_index_pattern (id, pattern, pattern_module, pattern_system, is_active)
                    VALUES (68,'v11-log-suricata-*', 'SURICATA', true, true);

                    INSERT INTO utm_menu (id, name, url, parent_id, type, dashboard_id, position, menu_active, menu_action, menu_icon, module_name_short)
                    VALUES (266, 'Suricata', 'discover/log-analyzer?patternId=63&indexPattern=v11-log-suricata-*', 200, 1, null, 66, false, false, null, 'SURICATA');

                    INSERT INTO utm_menu_authority (menu_id, authority_name)
                    VALUES ( 266, 'ROLE_USER');

                    INSERT INTO utm_menu_authority (menu_id, authority_name)
                    VALUES ( 266, 'ROLE_ADMIN');

            ]]>


        </sql>
    </changeSet>
</databaseChangeLog>
